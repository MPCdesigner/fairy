# all pieces come in the form of functions
# funtions are called to obtain the legal moves a piece can make on a given board at a certain location
# viz. p(board, file, rank) gets the moves for piece p
# moves are in the form of a pair of a location, and the resulting board
^^^ partially outdated

- [x] leapers
- [ ] riders
- [ ] not putting the king in check (royalty)

- [x] make a chessboard
- [x] figure out where clicks land
- [x] put pieces on the chessboard
- [x] FEN -> board
- [ ] board -> FEN
- [x] move pieces on the chessboard
- [ ] get legal moves on chessboard, based on arbitrary fairy chess move properties
- [ ] determine check and checkmate
- [ ] make an engine that's good
- [ ] make object oriented
- [ ] make readfen() call drawer.update()

a proto-piece is simply a list of offsets, independent of location and surroundings of a piece

a piece is a function that takes in a board and loc and returns:
    legal locs to move to
    the resulting possible boards
(in the form of a dictionary)

to turn a proto-piece into a piece we need to:
    add the offsets to the given loc
    determine which resulting squares are legal

to do so, we have a series of modifiers, which:
    restrict possible moves
    define the results of possible moves

for example, a left-right-cylindrical modifier will allow some "illegal" coordinates by simply making them wrap around the board
a capture-by-replacement modifier simply disallows captures of friendly pieces, and allows capture of enemy pieces
a no-jumping modifier

that is to say, each modifier takes in a (loc, board) pair and either:
    returns False/None, meaning this is not allowed
    returns a new modified (loc,board) pair

therefore modifiers must be applied in order, and are not commutative
we must determine whether a move is cylindrical/noncylindrical before determine things such as capture by replacement

actually no.
cylindrical, circular modifiers, are special.

such modifiers are applied to both "dir" and "loc".
so for example, the cylindrical modifier would perform modular arithmetic on every loc after it is created
a circular modifier would be tricky, but it should be possible by modifying dir.
why is this necessary?
riders have to integrate with them
a cylindrical rider does not know where to stop. the only way is by hitting a duplicate.
if we go fully in a loop as i rider, we know to stop
then, we can filter it through ordinary modifiers such as capture by replacement
therefore to get all the rider moves, we move it as a leaper,
then we apply such special modifiers
then we add it to the candidate moves
and we loop until we hit a duplicate (the direction and aux of the duplicate must be the same, too)
(but then how to we figure out legal moves for hoppers, etc. on a cylinder?)
right. the modifier persists. to check if something is capturing by replacement with no jumps, for example,
we simply add the direction from the src to the dest repeatedly, BUT in between each addition, we perform the aforementioned special modifiers
this way you can, for example, jump, while also moving cylindrically or circularly
therefore every "move" is this tuple:
    (src, dest, dir, board, movemodifiers)

perhaps movemodifiers should be external, i don't know
also to consider, some moves (such as riders?) may branch into alternatives.
therefore each modifier applied to a move should return a list of the modified moves, which is either empty (illegal move in the first place) or one, or more

keep in mind all of this has to take place between functions

pieces start being able to jump by default, and are banned from jumping by a modifier

to make a leaper:
we get the list of offsets
then, we combine them with src to get a list of (src,dest)
we attach the dir, but NOT the board yet
we perform the modifier 

after the proto-phase (the 1st one) everything can be done in terms of lists of Moves

perhaps a downside of this scheme is that we cannot simply call makerider() on some leaper to get a rider.
we have to call it on the protoleaper
but that is not a huge loss

circular motion (rose):
2,1
1,2
-1,2
-2,1
-2,-1
-1,-2
1,-2
2,-1
however, you can go two ways around this circle.
therefore you cannot tell which should come next, based on the current dir
more data has to be provided
perhaps, we could have another element of the tuple, with any data necessary for the type of move being performed, e.x. clockwise and counterclockwise
this data will be in the form of a dictionary. keys and values can be added as needed

like roses, crooked bishops, for example, will take advantage of this data
call the data 'aux' for auxiliary

need to consider how to implement crooked pieces, skip/ski/slip pieces, etc.
crooked pieces are a special case of concatenation of move sets
in the case of, ex. bent rooks,
it's a ferz and then a rook.
however the rook must move OUTWARDS
that is probably something that can be built into the aux


it should not be a tuple, it should be an object
